from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User


class Server(models.Model):
    class Meta:
        verbose_name = "Link Connection"
        verbose_name_plural = "Link Connections"

    name = models.CharField(max_length=100)
    ip_address = models.GenericIPAddressField()
    username = models.CharField(max_length=100)
    port = models.IntegerField(default=22)
    ssh_key_deployed = models.BooleanField(default=False, help_text="Whether SSH key has been deployed")
    ssh_key_deployed_at = models.DateTimeField(null=True, blank=True)

    def __str__(self):
        return self.name


class MonitoredLog(models.Model):
    class ParserChoices(models.TextChoices):
        GENERIC_ERROR = "GENERIC_ERROR", "Generic Error Log"
        APACHE_ERROR = "APACHE_ERROR", "Apache Error Log"
        NGINX_ERROR = "NGINX_ERROR", "Nginx Error Log"
        CRON_STATUS = "CRON_STATUS", "Cron Status Log"

    server = models.ForeignKey(Server, on_delete=models.CASCADE)
    application_name = models.CharField(max_length=50)
    log_path = models.CharField(max_length=255)
    last_read_offset = models.BigIntegerField(default=0)
    parser_type = models.CharField(
        max_length=20,
        choices=ParserChoices.choices,
        default=ParserChoices.GENERIC_ERROR
    )

    class Meta:
        verbose_name = "Track Activity"
        verbose_name_plural = "Track Activities"

    def __str__(self):
        return f"{self.application_name} on {self.server.name}"


class LogEvent(models.Model):
    monitored_log = models.ForeignKey(MonitoredLog, on_delete=models.CASCADE)
    log_level = models.CharField(max_length=50)
    message = models.TextField()
    ip_address = models.GenericIPAddressField(
        null=True,
        blank=True,
        help_text="The client IP address, if available."
    )
    first_seen = models.DateTimeField(default=timezone.now)
    last_seen = models.DateTimeField(default=timezone.now)
    event_count = models.PositiveIntegerField(default=1)
    is_notified = models.BooleanField(default=False)

    class Meta:
        indexes = [
            models.Index(fields=["monitored_log", "message"]),
        ]

    def __str__(self):
        return f"[{self.log_level}] ({self.event_count}x) on {self.monitored_log.application_name}"


class AnalysisRule(models.Model):
    class ActionType(models.TextChoices):
        INVESTIGATE = "INVESTIGATE", "Investigate"
        BLOCK_IP = "BLOCK_IP", "Block IP Address"
        IGNORE = "IGNORE", "Ignore"
        FYI = "FYI", "For Your Information"

    name = models.CharField(max_length=200)
    pattern_to_match = models.CharField(max_length=255, unique=True)
    explanation = models.TextField()
    recommendation = models.CharField(
        max_length=20,
        choices=ActionType.choices,
        default=ActionType.INVESTIGATE
    )
    llm_generated = models.BooleanField(default=False, help_text="Whether this rule was auto-generated by LLM")
    solution = models.TextField(blank=True, default="", help_text="Step-by-step solution commands generated by LLM")

    def __str__(self):
        return self.name


class SystemMetric(models.Model):
    """Stores collected system metrics"""
    server = models.ForeignKey(Server, on_delete=models.CASCADE, related_name="metrics")
    timestamp = models.DateTimeField(default=timezone.now, db_index=True)
    
    # CPU metrics
    cpu_percent = models.FloatField()
    cpu_count = models.IntegerField(null=True, blank=True, help_text="Logical CPU count")
    physical_cpu_count = models.IntegerField(null=True, blank=True, help_text="Physical CPU cores")
    cpu_load_avg_1m = models.FloatField(null=True, blank=True)
    cpu_load_avg_5m = models.FloatField(null=True, blank=True)
    cpu_load_avg_15m = models.FloatField(null=True, blank=True)
    
    # Memory metrics
    memory_total = models.BigIntegerField()  # bytes
    memory_available = models.BigIntegerField()  # bytes
    memory_percent = models.FloatField()
    memory_used = models.BigIntegerField()  # bytes
    memory_buffers = models.BigIntegerField(null=True, blank=True)  # bytes
    memory_cached = models.BigIntegerField(null=True, blank=True)  # bytes
    memory_shared = models.BigIntegerField(null=True, blank=True)  # bytes
    swap_total = models.BigIntegerField(null=True, blank=True)
    swap_used = models.BigIntegerField(null=True, blank=True)
    swap_percent = models.FloatField(null=True, blank=True)
    
    # Disk metrics (JSON field for multiple disks)
    # Enhanced structure: {"/": {"total": ..., "used": ..., "percent": ..., "disk_type": "SSD", "raid": "none", "physical_disk": "sda"}}
    disk_usage = models.JSONField(default=dict)
    
    # Network metrics (JSON field for multiple interfaces)
    network_io = models.JSONField(default=dict)
    network_connections = models.IntegerField(null=True, blank=True)
    
    class Meta:
        ordering = ["-timestamp"]
        indexes = [
            models.Index(fields=["server", "-timestamp"]),
        ]

    def __str__(self):
        return f"{self.server.name} - {self.timestamp}"


class Anomaly(models.Model):
    """Detected anomalies in system metrics"""
    class Severity(models.TextChoices):
        LOW = "LOW", "Low"
        MEDIUM = "MEDIUM", "Medium"
        HIGH = "HIGH", "High"
        CRITICAL = "CRITICAL", "Critical"
    
    server = models.ForeignKey(Server, on_delete=models.CASCADE, related_name="anomalies")
    metric = models.ForeignKey(SystemMetric, on_delete=models.CASCADE, related_name="anomalies")
    timestamp = models.DateTimeField(default=timezone.now, db_index=True)
    
    metric_type = models.CharField(max_length=50)  # "cpu", "memory", "disk", "network"
    metric_name = models.CharField(max_length=100)  # e.g., "cpu_percent", "memory_percent"
    metric_value = models.FloatField()
    anomaly_score = models.FloatField()  # IsolationForest score or ADTK score
    severity = models.CharField(max_length=20, choices=Severity.choices, default=Severity.MEDIUM)
    
    # LLM-generated explanation (optional)
    explanation = models.TextField(blank=True)
    llm_generated = models.BooleanField(default=False)
    
    # Status
    acknowledged = models.BooleanField(default=False)
    resolved = models.BooleanField(default=False)
    resolved_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ["-timestamp"]
        indexes = [
            models.Index(fields=["server", "-timestamp"]),
            models.Index(fields=["severity", "-timestamp"]),
        ]

    def __str__(self):
        return f"{self.server.name} - {self.metric_type} anomaly at {self.timestamp}"


class Service(models.Model):
    """Detected services on servers"""
    server = models.ForeignKey(Server, on_delete=models.CASCADE, related_name="services")
    name = models.CharField(max_length=100)
    status = models.CharField(max_length=50, default="unknown")  # running, stopped, failed
    service_type = models.CharField(max_length=50, default="systemd")  # systemd, process, port
    port = models.IntegerField(null=True, blank=True)
    process_id = models.CharField(max_length=50, null=True, blank=True)
    last_checked = models.DateTimeField(default=timezone.now)
    monitoring_enabled = models.BooleanField(default=False, help_text="Whether monitoring is enabled for this service")
    
    class Meta:
        unique_together = [["server", "name"]]
        indexes = [
            models.Index(fields=["server", "status"]),
            models.Index(fields=["last_checked"]),
        ]
    
    def __str__(self):
        return f"{self.name} on {self.server.name} ({self.status})"


class MonitoringConfig(models.Model):
    """Configuration for monitoring each server"""
    server = models.OneToOneField(Server, on_delete=models.CASCADE, related_name="monitoring_config")
    
    # Collection settings
    collection_interval_seconds = models.IntegerField(default=60, help_text="Seconds between metric collections")
    adaptive_collection_enabled = models.BooleanField(default=False, help_text="Enable adaptive collection frequency")
    anomaly_detection_interval = models.IntegerField(default=15, help_text="Collection interval when anomaly detected (seconds)")
    enabled = models.BooleanField(default=True)
    
    # Anomaly detection settings
    use_adtk = models.BooleanField(default=True, help_text="Use ADTK (primary) vs IsolationForest (fallback)")
    use_isolation_forest = models.BooleanField(default=False, help_text="Use IsolationForest (fallback)")
    contamination = models.FloatField(default=0.1, help_text="Expected proportion of anomalies (0.0-0.5)")
    window_size = models.IntegerField(default=100, help_text="Number of recent metrics for training")
    
    # ADTK-specific settings
    adtk_threshold_factor = models.FloatField(default=2.0, help_text="Threshold factor for ADTK detectors")
    adtk_window_size = models.IntegerField(default=30, help_text="Window size for ADTK time-series analysis")
    
    # Thresholds (fallback if ML fails)
    cpu_threshold = models.FloatField(default=80.0, help_text="CPU usage threshold (%)")
    memory_threshold = models.FloatField(default=90.0, help_text="Memory usage threshold (%)")
    disk_threshold = models.FloatField(default=90.0, help_text="Disk usage threshold (%)")
    
    # LLM settings
    use_llm_explanation = models.BooleanField(default=True, help_text="Always generate LLM explanations for anomalies")
    
    # Data retention settings
    retention_period_days = models.IntegerField(default=30, help_text="Days to keep raw metrics before deletion")
    aggregation_enabled = models.BooleanField(default=True, help_text="Enable metric aggregation")
    
    # Alert and monitoring control
    alert_suppressed = models.BooleanField(default=False, help_text="Suppress alerts for this server")
    monitoring_suspended = models.BooleanField(default=False, help_text="Suspend monitoring for this server")
    
    class Meta:
        verbose_name = "Monitoring Configuration"
        verbose_name_plural = "Monitoring Configurations"

    def __str__(self):
        return f"Monitoring config for {self.server.name}"


class AggregatedMetric(models.Model):
    """Aggregated metrics for long-term storage"""
    server = models.ForeignKey(Server, on_delete=models.CASCADE, related_name="aggregated_metrics")
    aggregation_type = models.CharField(max_length=20)  # "hourly", "daily"
    timestamp = models.DateTimeField(db_index=True)
    
    # Aggregated values
    cpu_avg = models.FloatField(null=True, blank=True)
    cpu_min = models.FloatField(null=True, blank=True)
    cpu_max = models.FloatField(null=True, blank=True)
    
    memory_avg = models.FloatField(null=True, blank=True)
    memory_min = models.FloatField(null=True, blank=True)
    memory_max = models.FloatField(null=True, blank=True)
    
    disk_avg = models.FloatField(null=True, blank=True)
    disk_min = models.FloatField(null=True, blank=True)
    disk_max = models.FloatField(null=True, blank=True)
    
    metric_count = models.IntegerField(default=0, help_text="Number of raw metrics aggregated")
    
    class Meta:
        unique_together = [["server", "aggregation_type", "timestamp"]]
        indexes = [
            models.Index(fields=["server", "aggregation_type", "-timestamp"]),
        ]
    
    def __str__(self):
        return f"{self.server.name} - {self.aggregation_type} - {self.timestamp}"

class EmailAlertConfig(models.Model):
    """Email configuration for sending alerts"""
    provider = models.CharField(max_length=50, default="custom")
    smtp_host = models.CharField(max_length=255)
    smtp_port = models.IntegerField(default=465)
    use_tls = models.BooleanField(default=False)
    smtp_username = models.EmailField()
    smtp_password = models.CharField(max_length=255)
    from_email = models.EmailField()
    alert_recipients = models.TextField()
    enabled = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"Email Alert Config ({self.provider})"


class AlertHistory(models.Model):
    """History of alerts sent and resolved"""
    class AlertType(models.TextChoices):
        CPU = "CPU", "CPU"
        MEMORY = "Memory", "Memory"
        DISK = "Disk", "Disk"
        CONNECTION = "CONNECTION", "Connection"
        SERVICE = "SERVICE", "Service"
    
    class AlertStatus(models.TextChoices):
        TRIGGERED = "triggered", "Triggered"
        RESOLVED = "resolved", "Resolved"
    
    server = models.ForeignKey(Server, on_delete=models.CASCADE, related_name="alert_history")
    alert_type = models.CharField(max_length=20, choices=AlertType.choices)
    status = models.CharField(max_length=20, choices=AlertStatus.choices, default=AlertStatus.TRIGGERED)
    value = models.FloatField(help_text="Current metric value")
    threshold = models.FloatField(help_text="Threshold value")
    message = models.TextField()
    recipients = models.TextField(help_text="Comma-separated list of email recipients")
    sent_at = models.DateTimeField(default=timezone.now, db_index=True)
    resolved_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ["-sent_at"]
        indexes = [
            models.Index(fields=["server", "-sent_at"]),
            models.Index(fields=["status", "-sent_at"]),
        ]
        verbose_name = "Alert History"
        verbose_name_plural = "Alert History"
    
    def __str__(self):
        return f"{self.server.name} - {self.alert_type} {self.status} at {self.sent_at}"


class Role(models.Model):
    """RBAC Role - defines a set of permissions that can be assigned to users"""
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True, help_text="Description of this role's responsibilities")
    is_protected = models.BooleanField(default=False, help_text="Protected roles cannot be renamed or deleted")

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Role"
        verbose_name_plural = "Roles"
        ordering = ['name']

    def __str__(self):
        return self.name

    def get_privileges(self):
        """Get all privileges for this role"""
        return self.role_privileges.select_related('privilege')


class Privilege(models.Model):
    """Individual permission that can be assigned to roles"""
    key = models.CharField(max_length=100, unique=True, help_text="Machine-readable key (e.g., 'view_dashboard')")
    label = models.CharField(max_length=200, help_text="Human-readable label (e.g., 'View Dashboard')")

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Privilege"
        verbose_name_plural = "Privileges"
        ordering = ['key']

    def __str__(self):
        return self.label


class RolePrivilege(models.Model):
    """Many-to-many mapping between roles and privileges"""
    role = models.ForeignKey(Role, on_delete=models.CASCADE, related_name='role_privileges')
    privilege = models.ForeignKey(Privilege, on_delete=models.CASCADE, related_name='role_privileges')

    class Meta:
        unique_together = [['role', 'privilege']]
        verbose_name = "Role Privilege"
        verbose_name_plural = "Role Privileges"

    def __str__(self):
        return f"{self.role.name} - {self.privilege.label}"


class UserACL(models.Model):
    """Access Control List for Staff Users - now uses role-based permissions"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='acl')
    role = models.ForeignKey(Role, on_delete=models.SET_NULL, null=True, blank=True,
                           help_text="Role that defines this user's permissions")

    # DEPRECATED: These boolean flags are kept for backward compatibility
    # but should be removed after migration to role-based system
    can_view_dashboard = models.BooleanField(default=True, help_text="[DEPRECATED] Use role privileges")
    can_edit_thresholds = models.BooleanField(default=False, help_text="[DEPRECATED] Use role privileges")
    can_halt_monitoring = models.BooleanField(default=False, help_text="[DEPRECATED] Use role privileges")
    can_mute_notifications = models.BooleanField(default=False, help_text="[DEPRECATED] Use role privileges")
    can_add_server = models.BooleanField(default=False, help_text="[DEPRECATED] Use role privileges")
    can_edit_server = models.BooleanField(default=False, help_text="[DEPRECATED] Use role privileges")
    can_delete_server = models.BooleanField(default=False, help_text="[DEPRECATED] Use role privileges")

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "User ACL"
        verbose_name_plural = "User ACLs"
        ordering = ['user__username']

    def __str__(self):
        role_name = self.role.name if self.role else "No Role"
        return f"ACL for {self.user.username} ({role_name})"

    def has_privilege(self, privilege_key):
        """Check if user has a specific privilege"""
        # Root Admin (superuser) has all privileges
        if self.user.is_superuser:
            return True

        # Check role-based privileges
        if self.role and self.role.role_privileges.filter(privilege__key=privilege_key).exists():
            return True

        return False

    def get_all_privileges(self):
        """Get all privilege keys for this user"""
        if self.user.is_superuser:
            # Root Admin has all privileges
            return Privilege.objects.values_list('key', flat=True)

        if self.role:
            return self.role.role_privileges.values_list('privilege__key', flat=True)

        return []

    @classmethod
    def get_or_create_for_user(cls, user):
        """Get or create ACL for a user"""
        acl, created = cls.objects.get_or_create(user=user)
        if created and not user.is_superuser:
            # For new staff users, assign default Viewer role if it exists
            try:
                viewer_role = Role.objects.get(name="Viewer")
                acl.role = viewer_role
                acl.save()
            except Role.DoesNotExist:
                # Fallback to old boolean system if roles not yet set up
                acl.can_view_dashboard = True
                acl.save()
        return acl
